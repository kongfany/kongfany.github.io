<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>重新排序得到 2 的幂 - 大胖狗来了</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="kong" /><meta name="description" content="给定正整数 N ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。 如果我们可以通过上述方式得到 2 的幂，返回 true；否则，" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.87.0 with theme even" />


<link rel="canonical" href="https://kongfany.github.io/post/lcode869/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="重新排序得到 2 的幂" />
<meta property="og:description" content="给定正整数 N ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。 如果我们可以通过上述方式得到 2 的幂，返回 true；否则，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kongfany.github.io/post/lcode869/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-10-28T21:20:26+08:00" />
<meta property="article:modified_time" content="2021-10-28T21:20:26+08:00" />

<meta itemprop="name" content="重新排序得到 2 的幂">
<meta itemprop="description" content="给定正整数 N ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。 如果我们可以通过上述方式得到 2 的幂，返回 true；否则，"><meta itemprop="datePublished" content="2021-10-28T21:20:26+08:00" />
<meta itemprop="dateModified" content="2021-10-28T21:20:26+08:00" />
<meta itemprop="wordCount" content="5857">
<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="重新排序得到 2 的幂"/>
<meta name="twitter:description" content="给定正整数 N ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。 如果我们可以通过上述方式得到 2 的幂，返回 true；否则，"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">大胖狗来了</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">大胖狗来了</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">重新排序得到 2 的幂</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-10-28 </span>
        <div class="post-category">
            <a href="/categories/leetcode/"> Leetcode </a>
            </div>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#方法一搜索回溯--位运算">方法一：搜索回溯 + 位运算</a></li>
        <li><a href="#方法二预处理哈希表">方法二：预处理+哈希表</a>
          <ul>
            <li><a href="#向左位移">向左位移</a></li>
          </ul>
        </li>
        <li><a href="#2的幂">2的幂</a>
          <ul>
            <li><a href="#方法一二进制表示">方法一：二进制表示</a></li>
            <li><a href="#方法二判断是否为最大2的幂的约数">方法二：判断是否为最大2的幂的约数</a></li>
          </ul>
        </li>
        <li><a href="#全排列">全排列</a>
          <ul>
            <li><a href="#回溯法"><code>回溯法</code></a></li>
          </ul>
        </li>
        <li><a href="#全排列2">全排列2</a>
          <ul>
            <li><a href="#搜索回溯">搜索回溯</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <blockquote>
<p>给定正整数 N ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。</p>
<p>如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回 false。</p>
<p><strong>示例 1：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">输入：1
输出：true
</code></pre></td></tr></table>
</div>
</div><p><strong>示例 2：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">输入：10
输出：false
</code></pre></td></tr></table>
</div>
</div></blockquote>
<h2 id="方法一搜索回溯--位运算">方法一：搜索回溯 + 位运算</h2>
<p>将 n 的十进制表示视作一个字符数组，我们可以枚举该数组的所有排列，对每个不含前导零的排列判断其对应的整数是否为 2 的幂。</p>
<p>这可以拆分成两个子问题：</p>
<ul>
<li>枚举可能包含重复字符的数组的全排列</li>
<li>判断一个整数是否为 2 的幂</li>
</ul>
<p>对于本题的具体实现，我们可以在递归搜索全排列的同时，计算出当前排列的已枚举的部分所对应的整数 num。在我们枚举当前排列的下一个字符 ch 时，将 ch 加到 num 的末尾，即 num = num * 10 + ch - &lsquo;0&rsquo;，然后递归进入下一层。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">isPowerOfTwo</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reorderedPowerOf2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">nums</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">vis</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">m</span>

        <span class="k">def</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">m</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">isPowerOfTwo</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
                <span class="c1"># 不能有前导零</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ch</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">vis</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">ch</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]):</span>
                    <span class="k">continue</span>
                <span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">backtrack</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="nb">ord</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)):</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">backtrack</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>复杂度分析：</p>
<ul>
<li>
<p>时间复杂度：O(m!)。其中m=⌊log_10 <em>n</em>⌋+1,即n的十进制表示的长度。</p>
<p><img src="/images/202111/3.png" alt=""></p>
</li>
<li>
<p>空间复杂度：O(m)。我们需要 O(m) 的标记数组，同时在递归的时候栈深度会达到 O(m)，因此总空间复杂度为 O(m+m)=O(2m)=O(m)。</p>
</li>
</ul>
<h2 id="方法二预处理哈希表">方法二：预处理+哈希表</h2>
<p>由于我们可以按任何顺序将数字重新排列，因此对于两个不同的整数a和b，如果对于两个不同的整数a和b，如果其十进制表示的字符数组，从小到大排序后的结果是相同的，那么若a能够重排得到2的幂，b也可以；若a不能重排得到2的幂，那么b也不能。</p>
<p>进一步地，只要a和b的十进制表示的字符数组中，从0到9每个字符出现次数，在a和b中都是一样的，那么a和b能否得到2的幂的结果是一样的。</p>
<p>由于2^29&lt;10^9&lt;2^30，因此在[1,10^9] 范围内有 2^0,2^1,&hellip;,2^29一共 30 个 2 的幂。对这 30 个数的每个数，我们可以预处理其十进制表示的字符数组中从 0 到 9 每个字符的出现次数，记在一个长度为 10 的数组中，并用一哈希表记录这些数组。对于数字 n，我们同样统计其十进制表示的字符数组中从 0 到 9 每个字符的出现次数，然后去哈希表中查找，若存在则说明 n 可以通过重排得到 2 的幂，否则不能。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">countDigits</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span><span class="c1">#统计对应十进制各个数字出现的次数。</span>
    <span class="n">cnt</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10</span>
    <span class="k">while</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">cnt</span><span class="p">[</span><span class="n">n</span> <span class="o">%</span> <span class="mi">10</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">n</span> <span class="o">//=</span> <span class="mi">10</span>
    <span class="c1">#tuple():列表转元组</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span>
<span class="c1">#1&lt;&lt;i,左移，相当于1*2^i</span>
<span class="n">powerOf2Digits</span> <span class="o">=</span> <span class="p">{</span><span class="n">countDigits</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">30</span><span class="p">)}</span><span class="c1">#集合</span>

<span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">reorderedPowerOf2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">countDigits</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">in</span> <span class="n">powerOf2Digits</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">(0, 1, 0, 0, 0, 0, 0, 0, 0, 0)
(0, 0, 1, 0, 0, 0, 0, 0, 0, 0)
(0, 0, 0, 0, 1, 0, 0, 0, 0, 0)
(0, 0, 0, 0, 0, 0, 0, 0, 1, 0)
(0, 1, 0, 0, 0, 0, 1, 0, 0, 0)
(0, 0, 1, 1, 0, 0, 0, 0, 0, 0)
(0, 0, 0, 0, 1, 0, 1, 0, 0, 0)
(0, 1, 1, 0, 0, 0, 0, 0, 1, 0)
(0, 0, 1, 0, 0, 1, 1, 0, 0, 0)
(0, 1, 1, 0, 0, 1, 0, 0, 0, 0)
(1, 1, 1, 0, 1, 0, 0, 0, 0, 0)
(1, 0, 1, 0, 1, 0, 0, 0, 1, 0)
(1, 0, 0, 0, 1, 0, 1, 0, 0, 1)
(0, 1, 1, 0, 0, 0, 0, 0, 1, 1)
(0, 1, 0, 1, 1, 0, 1, 0, 1, 0)
(0, 0, 1, 1, 0, 0, 1, 1, 1, 0)
(0, 0, 0, 1, 0, 2, 2, 0, 0, 0)
(1, 2, 1, 1, 0, 0, 0, 1, 0, 0)
(0, 1, 2, 0, 2, 0, 1, 0, 0, 0)
(0, 0, 2, 0, 1, 1, 0, 0, 2, 0)
(1, 1, 0, 0, 1, 1, 1, 1, 1, 0)
(1, 1, 2, 0, 0, 1, 0, 1, 0, 1)
(1, 1, 0, 1, 3, 0, 0, 0, 0, 1)
(1, 0, 0, 1, 0, 0, 1, 0, 4, 0)
(0, 2, 1, 0, 0, 0, 2, 3, 0, 0)
(0, 0, 1, 3, 2, 2, 0, 0, 0, 0)
(1, 1, 0, 0, 1, 0, 2, 1, 2, 0)
(0, 2, 2, 1, 1, 0, 0, 2, 1, 0)
(0, 0, 1, 1, 2, 2, 2, 0, 1, 0)
(1, 1, 1, 1, 0, 1, 1, 1, 1, 1)
{(0, 1, 0, 0, 0, 0, 0, 0, 0, 0), (0, 1, 1, 0, 0, 0, 0, 0, 1, 0), (0, 1, 2, 0, 2, 0, 1, 0, 0, 0), (1, 1, 0, 0, 1, 0, 2, 1, 2, 0), (0, 0, 0, 1, 0, 2, 2, 0, 0, 0), (1, 2, 1, 1, 0, 0, 0, 1, 0, 0), (0, 0, 1, 0, 0, 0, 0, 0, 0, 0), (0, 2, 2, 1, 1, 0, 0, 2, 1, 0), (0, 1, 0, 1, 1, 0, 1, 0, 1, 0), (0, 0, 0, 0, 0, 0, 0, 0, 1, 0), (0, 0, 0, 0, 1, 0, 0, 0, 0, 0), (0, 2, 1, 0, 0, 0, 2, 3, 0, 0), (0, 1, 0, 0, 0, 0, 1, 0, 0, 0), (0, 1, 1, 0, 0, 1, 0, 0, 0, 0), (0, 0, 1, 1, 0, 0, 1, 1, 1, 0), (1, 1, 0, 0, 1, 1, 1, 1, 1, 0), (0, 0, 1, 3, 2, 2, 0, 0, 0, 0), (0, 0, 1, 1, 0, 0, 0, 0, 0, 0), (1, 1, 1, 1, 0, 1, 1, 1, 1, 1), (0, 0, 1, 1, 2, 2, 2, 0, 1, 0), (0, 0, 0, 0, 1, 0, 1, 0, 0, 0), (0, 1, 1, 0, 0, 0, 0, 0, 1, 1), (0, 0, 1, 0, 0, 1, 1, 0, 0, 0), (1, 1, 0, 1, 3, 0, 0, 0, 0, 1), (1, 0, 0, 1, 0, 0, 1, 0, 4, 0), (0, 0, 2, 0, 1, 1, 0, 0, 2, 0), (1, 0, 1, 0, 1, 0, 0, 0, 1, 0), (1, 1, 2, 0, 0, 1, 0, 1, 0, 1), (1, 1, 1, 0, 1, 0, 0, 0, 0, 0), (1, 0, 0, 0, 1, 0, 1, 0, 0, 1)}
(0, 0, 0, 0, 1, 0, 1, 0, 0, 0)
True
</code></pre></td></tr></table>
</div>
</div><p>复杂度分析</p>
<ul>
<li>时间复杂度O(logn)。统计 n 的每个数字的出现次数需要 O(logn) 的时间。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<blockquote>
<h3 id="向左位移">向左位移</h3>
<p>‘&laquo;’ 操作符将执行按位的“左移”，即左操作数的值被右操作数给出的位数移动到左：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"> #2 = 0b10
 2 &lt;&lt; 2
 #输出: 8
 #8 = 0b1000

 bin(2 &lt;&lt; 2)
 #输出: 0b1000
</code></pre></td></tr></table>
</div>
</div><p>执行1的左位移位相当于乘以2</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"> 7 &lt;&lt; 1
 #输出: 14
</code></pre></td></tr></table>
</div>
</div><p>执行n的左位移位相当于乘以2**n ：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"> 3 &lt;&lt; 4
 #输出: 48
</code></pre></td></tr></table>
</div>
</div></blockquote>
<h2 id="2的幂">2的幂</h2>
<blockquote>
<p>给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。</p>
<p>如果存在一个整数 x 使得 n = 2x ，则认为 n 是 2 的幂次方。</p>
<p><strong>提示：</strong></p>
<ul>
<li><code>-2^31 &lt;= n &lt;= 2^31 - 1</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">输入：n = 1
输出：true
解释：20 = 1
</code></pre></td></tr></table>
</div>
</div><p><strong>示例 2：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">输入：n = 16
输出：true
解释：24 = 16
</code></pre></td></tr></table>
</div>
</div></blockquote>
<h3 id="方法一二进制表示">方法一：二进制表示</h3>
<p>思路与算法：</p>
<p>一个数n是2的幂，当且仅当n是正整数，并且n的二进制表示中包含1个1。</p>
<p>因此可以考虑为运算，将n的二进制表示中最低位的那个1提取出来，再判断剩余的数值是否是0即可。</p>
<p>下面介绍两种常见的与<code>二进制表示中最低位</code>相关的位运算技巧：</p>
<ol>
<li>
<p>n &amp; (n-1):其中&amp;表示按位与运算（两个1为1，其余为0）。该运算技巧可以直接将n的二进制表示的最低位1移除，它的原理如下：</p>
<p>假设n的二进制表示为：(a10&hellip;0)₂,其中a表示若干个高位，1表示最低位的那个1,那么n-1的二进制为(a01&hellip;1)₂,将(a10&hellip;0)₂和(a01&hellip;1)₂进行按位与运算，高位a不变，在这之后的所有位都会变为0，这样就将最低位的那个1移除了。</p>
<p>因此，如果n是正整数并且<code>n &amp; (n-1) = 0</code>，那么n就是2的幂。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isPowerOfTwo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>n &amp; (-n):其中-n是n的相反数，是一个负数。该位运算技巧可以直接获取n二进制的最低位的1，它的原理为：</p>
<p>假设n的二进制为：(a10&hellip;0)₂，那么-n的二进制为(a'01&hellip;1)₂+(1)₂=(a'10&hellip;0)₂,其中a‘为a的每一位取反，将(a10&hellip;0)₂和(a'10&hellip;0)₂进行按位与运算，高位全部变为0，最低位的1以及之后的所有0不变，最低位的1以及之后的所有0不变，这样就获取了n二进制表示的最低位的1。</p>
<p>因此，如果n是正整数并且<code>n &amp; (-n) = n</code>，那么n就是2的幂。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">isPowerOfTwo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span>
</code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(1)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h3 id="方法二判断是否为最大2的幂的约数">方法二：判断是否为最大2的幂的约数</h3>
<p>思路和算法：</p>
<p>除了使用二进制表示判断之外，还有一种较为取巧的方法。</p>
<p>在题目给定的32位有符的整数的范围内，最大的2的幂为2^30=1073741824。我们只需判断n是否是2^30的约数即可。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>

    <span class="n">BIG</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">30</span>

    <span class="k">def</span> <span class="nf">isPowerOfTwo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">Solution</span><span class="o">.</span><span class="n">BIG</span> <span class="o">%</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span>
</code></pre></td></tr></table>
</div>
</div><p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(1)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="全排列">全排列</h2>
<blockquote>
<p>给定一个<code>不含重复</code>数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p>
<p>示例 1：</p>
<p>输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
示例 2：</p>
<p>输入：nums = [0,1]
输出：[[0,1],[1,0]]
示例 3：</p>
<p>输入：nums = [1]
输出：[[1]]</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 6
-10 &lt;= nums[i] &lt;= 10
nums 中的所有整数 互不相同</p>
</blockquote>
<p>预备知识：</p>
<h3 id="回溯法"><code>回溯法</code></h3>
<p>一种通过探索所有可能候选解来找出所有的解的算法。如果候选解被确认不是一个解（或者至少不是最后一个解），回溯算法会通过</p>
<p>思路和算法：</p>
<p>问题可以看做n个排列成一行的空格，需要从左往右依次填入题目给定的n个数，每个数只能使用一次。可以很直接的想到一种穷举算法，即从左到右每一个位置都依次尝试填入一个数，看能不能填完这n个空格，在程序中使用回溯法来模拟这个过程。</p>
<p>定义递归函数backtrack(first,output)表示从左向右填到first个位置，当前排列为output。那么整个递归函数分为两个情况：</p>
<ul>
<li>如果first=n，说明已经填完n个位置（注意下标从0开始），找到了一个可行的解，将output放入答案数组中，递归结束。</li>
<li>如果first&lt;n，应考虑这第first个位置要填那个数。根据题目要求我们不能填已经填过的数，因为可以想到：定义一个标记数组vis[]来标记已经填过的数，那么在填第first个数的时候，遍历题目给定的n个数，如果这个数美原油被标记过，就尝试填入，并将其标记，继续尝试填下一个位置，即调用函数backtrack(first+1,output)。回溯的时候要撤销这一个位置填的数以及标记，并继续尝试其他未被标记过的数</li>
</ul>
<p>使用标记数组来处理填过的数是一个很直观的思路，但是标记数组增加了算法的空间复杂度。我们可以将题目给定的n个数的数组nums划分为左右两个部分，左边的表示已经填过的数，右边表示待填的数，在回溯的时候只要动态的维护这个数组即可。</p>
<p>具体来说，假设我们已经填到第first个位置，那么nums数组中[0,first-1]是已填过的数的集合，[first,n-1]是待填的数的集合。尝试用[first,n-1]的数去填第first个数，假设待填的数的下标为i，那么填完以后，我们将第i个数和第first个数交换，即使能够在填第first+1个数和第first个数交换，即能使得在填第first+1个数的时候nums数组的[0,first]部分为已填过的数，[first+1,n-1]为待填的数，回溯的时候交换回来即能完成撤销操作。回退就是指撤销对当前数字的选择，回退到上一步，未选择的状态</p>
<p>举例：假设[2,5,8,9,10]这5个数要填入，已经填到第3个位置，已经填了[8,9]这两个数，那么这个数组目前为[8,9|2,5,10]这样的状态，分隔符区分了左右两个部分。假设这个位置填10，为了维护数组，我们将2和10交换，即能使得数组继续保持分隔符左边的数已经填过，右边的待填[8,9,10|2,5]</p>
<p><img src="/images/202111/1.png" alt=""></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">permute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;
</span><span class="s2">        :type nums: List[int]
</span><span class="s2">        :rtype: List[List[int]]
</span><span class="s2">        &#34;&#34;&#34;</span>
        <span class="k">def</span> <span class="nf">backtrack</span><span class="p">(</span><span class="n">first</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># 所有数都填完了</span>
            <span class="k">if</span> <span class="n">first</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>  
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nums</span><span class="p">[:])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="c1"># 动态维护数组</span>
                <span class="n">nums</span><span class="p">[</span><span class="n">first</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">first</span><span class="p">]</span>
                <span class="c1"># 继续递归填下一个数</span>
                <span class="n">backtrack</span><span class="p">(</span><span class="n">first</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="c1"># 撤销操作</span>
                <span class="n">nums</span><span class="p">[</span><span class="n">first</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">first</span><span class="p">]</span>
        
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">backtrack</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></td></tr></table>
</div>
</div><p>复杂度分析：</p>
<ul>
<li>
<p>时间复杂度：O(n*n!)，其中n为序列的长度</p>
<p><img src="/images/202111/2.png" alt=""></p>
</li>
<li>
<p>空间复杂度：O(n)。除了答案数组外，递归函数在递归过程中需要为每一层递归函数分配栈空间，所以需要额外的空间且该空间取决于递归的深度，可知递归调用深度为O(n)。</p>
</li>
</ul>
<h2 id="全排列2">全排列2</h2>
<blockquote>
<p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p>
<p>示例 1：</p>
<p>输入：nums = [1,1,2]
输出：
[[1,1,2],
[1,2,1],
[2,1,1]]
示例 2：</p>
<p>输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 8
-10 &lt;= nums[i] &lt;= 10</p>
</blockquote>
<h3 id="搜索回溯">搜索回溯</h3>
<p>我们将这个问题看作有 n 个排列成一行的空格，我们需要从左往右依次填入题目给定的 nn 个数，每个数只能使用一次。那么很直接的可以想到一种穷举的算法，即从左往右每一个位置都依此尝试填入一个数，看能不能填完这 n 个空格，在程序中我们可以用「回溯法」来模拟这个过程。</p>
<p>我们定义递归函数 backtrack(idx, perm) 表示当前排列为 perm，下一个待填入的位置是第 idx 个位置（下标从 0 开始）。那么整个递归函数分为两个情况：</p>
<ul>
<li>如果 idx==n，说明我们已经填完了 n 个位置，找到了一个可行的解，我们将 perm 放入答案数组中，递归结束。</li>
<li>如果 idx&lt;n，我们要考虑第 idx 个位置填哪个数。根据题目要求我们肯定不能填已经填过的数，因此很容易想到的一个处理手段是我们定义一个标记数组 vis 来标记已经填过的数，那么在填第 idx 个数的时候我们遍历题目给定的 n 个数，如果这个数没有被标记过，我们就尝试填入，并将其标记，继续尝试填下一个位置，即调用函数 backtrack(idx + 1, perm)。搜索回溯的时候要撤销该个位置填的数以及标记，并继续尝试其他没被标记过的数。</li>
</ul>
<p>但题目解到这里并没有满足「全排列不重复」 的要求，在上述的递归函数中我们会生成大量重复的排列，因为对于第 idx 的位置，如果存在重复的数字 i，我们每次会将重复的数字都重新填上去并继续尝试导致最后答案的重复，因此我们需要处理这个情况。</p>
<p>要解决重复问题，只要设定一个规则，保证在填第idx个数的时候重复数字只会被填入一次即可。而在本题解中，选择对原数组排序，保证相同的数字都相邻，然后每次填入的数一定是这个数所在重复数集合中<code>从左往右第一个 未被填过的数字</code>，即如下的判断条件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
	<span class="k">continue</span>
</code></pre></td></tr></table>
</div>
</div><p>这个判断条件保证了对于重复数的集合，一定是从左向右逐个填入的。</p>
<p>假设有三个重复数排完序后相邻，我们一定保证每次都是拿从左往右的第一个未被填过的数字，即整个数组的状态其实是保证了，（未填，未填，未填）到（填入，未填，未填）再到（填入，填入，未填）最后到（填入，填入，填入）的过程，因此可以达到去重的目标。</p>
<p><code>！！！</code></p>
<p>for循环保证了从数组中从前往后一个一个取值，再用if判断条件。所以nums[i - 1]一定比nums[i]先被取值和判断。如果nums[i - 1]被取值了，那vis[i - 1]会被置1，只有当递归再回退到这一层时再将它置0。每递归一层都是在寻找数组对应于递归深度位置的值，每一层里用for循环来寻找。所以当vis[i - 1] == 1时，说明nums[i - 1]和nums[i]分别属于两层递归中，也就是我们要用这两个数分别放在数组的两个位置，这时不需要去重。但是当vis[i - 1] == 0时，说明nums[i - 1]和nums[i]属于同一层递归中（只是for循环进入下一层循环），也就是我们要用这两个数放在数组中的同一个位置上，这就是我们要去重的情况。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">permuteUnique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
        <span class="n">nums</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">res</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">ans</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>
        <span class="n">visited</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span>
        <span class="k">def</span> <span class="nf">dfs</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span><span class="o">==</span><span class="n">n</span><span class="p">:</span>
                <span class="c1">#不是append(ans)，区别是深拷贝和浅拷贝</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ans</span><span class="p">[::])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="n">ans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
                <span class="n">dfs</span><span class="p">()</span>
                <span class="n">ans</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">dfs</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">res</span>
</code></pre></td></tr></table>
</div>
</div><p><img src="/images/202111/869.jpg" alt=""></p>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度：O(n*n!)</li>
<li>空间复杂度：O(n)，需要O(n)的标记数组，同时递归的时候栈深度会达到O(n)，因此总空间复杂度为O(n+n)=O(2n)=O(n)</li>
</ul>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/137486712">Python位操作符</a></p>
</blockquote>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">kong</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2021-10-28
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        <a class="prev" href="/post/federated-learning/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">联邦学习(Federated Learning)</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/lcode611/">
            <span class="next-text nav-default">有效三角形的个数</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=_JOXlp_emZaBjZ3IwcrMuImJ1puXlQ" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/kongfany" class="iconfont icon-github" title="github"></a>
      <a href="https://weibo.com/u/5947688533?is_all=1" class="iconfont icon-weibo" title="weibo"></a>
      <a href="https://www.zhihu.com/people/yu-ni-zhong-nian-bu-yu" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://space.bilibili.com/232669848" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="https://kongfany.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>kong</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>








</body>
</html>
