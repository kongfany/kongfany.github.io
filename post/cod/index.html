<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>伪装目标检测COD - 乐观积极的...</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="kong" /><meta name="description" content="paper cvpr2020 code 评估 blog ResNet resnet-残留块blog 2 3 ResNet 模型中的一个残差块的定义。在这个残差块中，根据条件选择了两种不同的快捷连接方式：投影连接和身" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.87.0 with theme even" />


<link rel="canonical" href="https://kongfany.github.io/post/cod/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="伪装目标检测COD" />
<meta property="og:description" content="paper cvpr2020 code 评估 blog ResNet resnet-残留块blog 2 3 ResNet 模型中的一个残差块的定义。在这个残差块中，根据条件选择了两种不同的快捷连接方式：投影连接和身" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kongfany.github.io/post/cod/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2023-07-26T11:33:09+08:00" />
<meta property="article:modified_time" content="2023-07-26T11:33:09+08:00" />

<meta itemprop="name" content="伪装目标检测COD">
<meta itemprop="description" content="paper cvpr2020 code 评估 blog ResNet resnet-残留块blog 2 3 ResNet 模型中的一个残差块的定义。在这个残差块中，根据条件选择了两种不同的快捷连接方式：投影连接和身"><meta itemprop="datePublished" content="2023-07-26T11:33:09+08:00" />
<meta itemprop="dateModified" content="2023-07-26T11:33:09+08:00" />
<meta itemprop="wordCount" content="9766">
<meta itemprop="keywords" content="Object Detection," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="伪装目标检测COD"/>
<meta name="twitter:description" content="paper cvpr2020 code 评估 blog ResNet resnet-残留块blog 2 3 ResNet 模型中的一个残差块的定义。在这个残差块中，根据条件选择了两种不同的快捷连接方式：投影连接和身"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">乐观积极的...</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">乐观积极的...</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">伪装目标检测COD</h1>

      <div class="post-meta">
        <span class="post-time"> 2023-07-26 </span>
        
          <span class="more-meta"> 9766 words </span>
          <span class="more-meta"> 20 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#resnet">ResNet</a></li>
        <li><a href="#cod">COD</a></li>
        <li><a href="#代码">代码</a></li>
        <li><a href="#基于像素与层级双对比的语义分割">基于像素与层级双对比的语义分割</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <blockquote>
<p><a href="https://openaccess.thecvf.com/content_CVPR_2020/papers/Fan_Camouflaged_Object_Detection_CVPR_2020_paper.pdf">paper</a> cvpr2020</p>
<p><a href="https://github.com/DengPingFan/SINet">code</a>  <a href="https://github.com/lartpang/PySODMetrics">评估</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/166572204">blog</a></p>
</blockquote>
<h2 id="resnet">ResNet</h2>
<blockquote>
<p><a href="https://nn.labml.ai/zh/resnet/index.html">resnet</a>-残留块<a href="https://blog.csdn.net/csdn_xmj/article/details/116546847">blog</a>  <a href="https://blog.csdn.net/weixin_44120025/article/details/120684496">2</a> <a href="https://blog.csdn.net/sazass/article/details/116864275">3</a></p>
</blockquote>
<p>ResNet 模型中的一个残差块的定义。在这个残差块中，根据条件选择了两种不同的快捷连接方式：投影连接和身份连接。</p>
<p>如果 <strong><code>stride</code></strong> 不等于 1 或者 <strong><code>in_channels</code></strong> 不等于 <strong><code>out_channels</code></strong>，则使用投影连接（ShortcutProjection）。投影连接通过一个卷积层将输入 <strong><code>x</code></strong> 的维度从 <strong><code>in_channels</code></strong> 转换为 <strong><code>out_channels</code></strong>，以匹配残差块的输出维度。这样做是为了处理输入和输出通道数不匹配或者步幅不为 1 的情况。</p>
<p>如果 <strong><code>stride</code></strong> 等于 1 并且 <strong><code>in_channels</code></strong> 等于 <strong><code>out_channels</code></strong>，则使用身份连接（nn.Identity()）。身份连接直接将输入 <strong><code>x</code></strong> 作为残差块的输出，不进行任何维度转换。</p>
<p>在残差块中，经过卷积操作和激活函数后，快捷连接和残差路径的输出将被相加，并通过第二个激活函数（ReLU）进行激活，得到最终的输出。</p>
<p>这种设计可以使得 ResNet 模型能够有效地处理不同通道数和步幅的情况，并引入了跳跃连接来缓解梯度消失问题，提高模型的训练效果和表示能力。</p>
<p>通过快捷连接和残差路径的相加操作，可以保留更多的信息和梯度流动，有助于提高模型的性能和训练效果。</p>
<p><strong><code>in_channels</code></strong> 和 <strong><code>out_channels</code></strong> 是两个整数参数，用于指定残差块的输入通道数和输出通道数。在卷积神经网络中，通道数指的是特征图的深度或通道的数量。</p>
<p>Bottleneck Residual Block（瓶颈残差块）是 ResNet 中的一种特殊类型的残差块，它在 ResNet 的深层网络中起到了重要的作用。 ResNet 的主要思想是通过跳跃连接（shortcut connection）和残差学习（residual learning）来解决梯度消失问题，使得网络能够更深地进行训练。而 Bottleneck Residual Block 是对传统的残差块的改进，旨在进一步减少模型的参数量和计算复杂度。 Bottleneck Residual Block 的设计主要包含三个关键部分： 1. <strong>瓶颈结构（Bottleneck）</strong>：它通过引入一个较小的瓶颈层，将输入特征图的维度显著降低，然后再将其扩展回原始维度。这样的设计可以减少计算量，并提高网络的表达能力。 2. <strong>1x1 卷积层</strong>：瓶颈结构中的第一个卷积层采用 1x1 的卷积核，用于降低输入特征图的维度。这样可以减少计算量和参数数量。 3. <strong>维度扩展</strong>：在瓶颈结构中，经过 1x1 卷积层降维后的特征图，会经过一个 3x3 卷积层进行特征提取，然后再通过另一个 1x1 卷积层将维度扩展回原始维度。这样的设计可以在保持网络性能的同时减少计算量。 通过引入瓶颈结构和适当的维度变换，Bottleneck Residual Block 在减少参数量的同时保持了网络的表达能力。这种设计使得 ResNet 能够构建更深的网络，同时保持较低的计算复杂度，更适合处理复杂的视觉任务。</p>
<p>ResNet（Residual Network）是一种深度卷积神经网络结构，通过残差学习（residual learning）和跳跃连接（shortcut connection）解决了深层网络中的梯度消失问题，使得网络能够更深地进行训练。ResNet 的主要结构特点是在网络中引入了残差块（Residual Block），并通过跳跃连接将输入直接添加到输出中，实现了信息的直接传递。 下面是 ResNet 的经典网络结构，以 ResNet-50 为例： 1. <strong>输入层</strong>：接受输入图像或特征图。 2. <strong>卷积层和池化层</strong>：一系列的卷积层和池化层用于提取特征和减小特征图的尺寸。 3. <strong>残差块</strong>：由多个残差块组成，每个残差块由多个卷积层和跳跃连接组成。其中，常用的残差块包括基本残差块（Basic Residual Block）和瓶颈残差块（Bottleneck Residual Block）。 4. <strong>全局平均池化层</strong>：对最后一个残差块的输出进行全局平均池化，将特征图的高度和宽度降为1。 5. <strong>全连接层</strong>：将全局平均池化后的特征图连接到全连接层，用于分类或回归任务。 6. <strong>输出层</strong>：根据任务需求，输出相应的结果，如分类标签或回归值。 经典的 ResNet 结构包括了不同深度的变种，如 ResNet-18、ResNet-34、ResNet-50、ResNet-101 和 ResNet-152 等。这些网络结构的主要区别在于残差块的堆叠方式和网络的深度。较深的网络通常能够提取更复杂的特征，但也会增加训练和推理的计算成本。 ResNet 的设计思想和网络结构的灵活性使其成为计算机视觉领域中广泛应用的模型，用于图像分类、目标检测、语义分割等任务。</p>
<p>以下是 ResNet-50 的网络结构图示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback">Input  
  |  
Conv1 (7x7, 64, stride 2)  
  |  
BatchNorm  
  |  
ReLU  
  |  
MaxPool (3x3, stride 2)  
  |  
Residual Block 1  
  |\  
  | Conv2 (1x1, 64)  
  | BatchNorm  
  | ReLU  
  | Conv3 (3x3, 64)  
  | BatchNorm  
  | ReLU  
  | Conv4 (1x1, 256)  
  | BatchNorm  
  | Shortcut Connection  
  | ReLU  
  |  
Residual Block 2  
  |\  
  | Conv5 (1x1, 128)  
  | BatchNorm  
  | ReLU  
  | Conv6 (3x3, 128)  
  | BatchNorm  
  | ReLU  
  | Conv7 (1x1, 512)  
  | BatchNorm  
  | Shortcut Connection  
  | ReLU  
  |  
Residual Block 3  
  |\  
  | Conv8 (1x1, 256)  
  | BatchNorm  
  | ReLU  
  | Conv9 (3x3, 256)  
  | BatchNorm  
  | ReLU  
  | Conv10 (1x1, 1024)  
  | BatchNorm  
  | Shortcut Connection  
  | ReLU  
  |  
Residual Block 4  
  |\  
  | Conv11 (1x1, 512)  
  | BatchNorm  
  | ReLU  
  | Conv12 (3x3, 512)  
  | BatchNorm  
  | ReLU  
  | Conv13 (1x1, 2048)  
  | BatchNorm  
  | Shortcut Connection  
  | ReLU  
  |  
Global Average Pooling  
  |  
Fully Connected Layer (Output)  
</code></pre></td></tr></table>
</div>
</div><p>上述结构中，Conv1 是一个 7x7 的卷积层，接着是 Batch Normalization 和 ReLU 激活函数。MaxPool 是一个最大池化层，其后是四个残差块（Residual Block）。每个残差块由多个卷积层和跳跃连接（Shortcut Connection）组成。最后经过全局平均池化（Global Average Pooling）后连接到全连接层，最终输出结果。 请注意，上述结构只是 ResNet-50 的一个示例，实际上，不同深度的 ResNet（如 ResNet-18、ResNet-34、ResNet-101 等）具有不同的层数和残差块的堆叠方式。</p>
<p>以下是对于给定参数的解释： - <code>n_blocks</code>: 一个整数列表，表示每个阶段（stage）中的残差块数量。例如，<code>n_blocks = [3, 4, 6, 3]</code> 表示 ResNet 中有四个阶段，每个阶段分别有 3、4、6、3 个残差块。 - <code>n_channels</code>: 一个整数列表，表示每个阶段中每个残差块的输出通道数。列表的长度应与 <code>n_blocks</code> 相同。例如，<code>n_channels = [64, 128, 256, 512]</code> 表示第一个阶段的每个残差块输出通道数为 64，第二个阶段为 128，以此类推。 - <code>bottlenecks</code>（可选）: 一个整数列表，表示每个阶段中是否使用瓶颈残差块（Bottleneck Residual Block）。如果没有指定该参数，则默认为 None，表示使用基本残差块（Basic Residual Block）。列表的长度应与 <code>n_blocks</code> 相同。例如，<code>bottlenecks = [True, True, False, False]</code> 表示第一个和第二个阶段使用瓶颈残差块，而第三个和第四个阶段使用基本残差块。 - <code>img_channels</code>: 输入图像的通道数，默认为 3，表示彩色图像的三个通道（红、绿、蓝）。 - <code>first_kernel_size</code>: 第一个卷积层的内核大小，默认为 7，表示一个 7x7 的卷积核。 这些参数用于初始化 ResNet 网络的构造函数，以定义网络的结构和特征图的通道数。具体的网络结构和层数取决于这些参数的配置。</p>
<p><a href="https://blog.csdn.net/weixin_42363544/article/details/123920699">dilation</a></p>
<p>在深度学习中，<code>dilation</code>（扩张率）是一种用于卷积操作的参数，用于控制卷积核在输入上的采样间隔。 在传统的卷积操作中，卷积核按照固定的步幅（stride）在输入上滑动，每次移动一个固定的距离进行采样。而使用 <code>dilation</code> 参数可以使卷积核在输入上以更大的间隔进行采样，从而扩大了感受野（receptive field）。 <code>dilation</code> 的值决定了卷积核在输入上的采样间隔。具体地，如果 <code>dilation</code> 为 1，则表示使用常规的卷积操作，卷积核之间没有间隔。如果 <code>dilation</code> 大于 1，则表示在输入上进行稀疏采样，卷积核之间有一定的间隔。较大的 <code>dilation</code> 值可以增加卷积核感受野的大小，从而捕捉更广阔的上下文信息。 使用 <code>dilation</code> 参数的卷积操作被称为 <code>dilated convolution</code> 或 <code>atrous convolution</code>。它在许多计算机视觉任务中被广泛应用，例如图像分割、语义分割和目标检测等，以便有效地捕捉图像中的全局和局部信息。</p>
<p><a href="https://zhuanlan.zhihu.com/p/31502877">resnet代码分析</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/184673895">机器学习模型训练全流程</a>  <a href="https://mp.weixin.qq.com/s/ZwfrIkHQMsHl_16xvCSejQ">2</a></p>
<p>利用resnet<a href="https://blog.csdn.net/u013972657/article/details/115869102">1</a> <a href="https://blog.csdn.net/Jackydyy/article/details/119238657">2</a> <a href="https://blog.csdn.net/weixin_52527544/article/details/127129303">3</a> <a href="https://blog.csdn.net/booklijian/article/details/113677810">4</a></p>
<p>？提取的特征是什么？卷积</p>
<p>ResNet（残差网络）是一种深度卷积神经网络结构，用于图像分类和特征提取任务。在 ResNet 中，最后一个全连接层之前的卷积层通常被视为特征提取器。 具体而言，ResNet 提取的特征是在网络的最后一个卷积层之前的输出。这个输出是一个具有固定维度的特征向量，其维度取决于所使用的 ResNet 模型的具体配置。 以 ResNet-50 为例，它的最后一个卷积层的输出是一个 2048 维的特征向量。这个特征向量可以被视为输入图像的高级表示，其中包含了图像的语义信息。这些特征可以用于图像分类、目标检测、图像检索等各种计算机视觉任务。 因此，ResNet 提取的特征是一个具有固定维度的向量，其中包含了输入图像的高级语义信息。具体的维度取决于所使用的 ResNet 模型的配置。</p>
<p>ResNet-50 是一个深度残差网络模型，用于图像分类和特征提取任务。当使用 ResNet-50 模型进行特征提取时，它会提取输入图像的高级语义特征。 具体来说，ResNet-50 模型通过一系列的卷积层、池化层和全连接层组成。在前向传播过程中，输入图像会经过一系列的卷积和池化操作，以提取图像中的低级特征，例如边缘和纹理。然后，这些低级特征会被传递到残差块（residual blocks）中，其中每个残差块包含多个卷积层，用于进一步提取图像中的高级语义特征。这些高级特征具有更丰富的语义信息，可以用于图像分类、目标检测、图像分割等任务。 因此，当使用 ResNet-50 模型进行特征提取时，提取到的特征是经过多层卷积和池化操作后得到的高级语义特征。这些特征通常被用作输入图像的紧凑表示，可以用于许多计算机视觉任务。</p>
<p>五个特征是什么？<a href="https://zhuanlan.zhihu.com/p/353235794">结构图</a></p>
<h2 id="cod">COD</h2>
<p><a href="https://zhuanlan.zhihu.com/p/166572204">blog</a> <a href="https://zhuanlan.zhihu.com/p/345564093">2</a> <a href="https://www.codetd.com/article/14746649#SINet_v1_31">3</a></p>
<p>对于输入图像（大小为H×W×3），通过ResNet-50后，5个特征大小分别为 (H/K,W/K) （K=4，4，8，16，32）。</p>
<p>bcwh：(batchsize,chanel,weight,height)</p>
<p>浅层特征保留了构造对象边界的空间细节，深层特征保留了用于定位对象的语义信息。我们将提取的特征分为低级{X0，X1}，中级{X2}，高级{X3，X4}，并通过串联，上采样进行组合 以及下采样操作。 SINet利用密集连接的来保存来自不同层的更多信息，然后使用<code>RF组件来扩大感受野</code>。</p>
<p><code>RF</code>结构如图所示，分为5个分支，图中的“C”为拼接操作（concatenation），前4个分支进行了拼接操作后，进行1×1卷积降维后与第5个分支相加</p>
<p>具体过程为：首先将低级特征X0，X1进行拼接操作后，连续进行两次下采样，再通过RF组件得到 rf_4S ；对X3，X4分别进行两次和四次的上采样后与X2一起进行拼接操作，通过RF组件得到rf_3S；对X4进行两次上采样后与X3进行拼接操作，通过RF组件得到 rf_2S ；X4通过RF组件得到 rf_1S 。</p>
<p>从先前的搜索模块<code>sa</code>中获得候选特征后，在识别模块中，我们需要精确地检测出被伪装的物体，文章里的方法扩展了具有密集连接功能的部分解码器组件（PDC） 更具体地说，PDC集成了SM的四个功能级别。其中的“×”表示multiplication操作，“C”表示concatenation操作。</p>
<p>从先前的搜索模块中获得候选特征后，在识别模块中，我们需要精确地检测出被伪装的物体。 文章里的方法扩展了具有密集连接功能的部分解码器组件（PDC） 更具体地说，PDC集成了SM的四个功能级别。</p>
<p>由于注意力机制可以有效地消除无关特征的干扰。 本文又引入了搜索注意（SA）模块来增强X2的中层特征并获得增强的伪装图</p>
<p>将前面得到的 rfs_i（i=1，2，3，4）通过PDC组件后得到 Cs,分为两步，一步将 Cs 进行八次上采样操作后得到 Ccsm ，另一步是将 Cs 经过Sigmoid激活函数后与X2一起进入SA模块（其实就是突出显示Cs初始伪装区域的最大函数），得到 Cℎ 。将 Cℎ 与X3-1与X4-1一起通过PDC模块，在进行八次上采样得到 Ccim 。使用交叉熵作为损失函数，公式如下：</p>
<p>L = L s CE(Ccsm, G) + L i CE(Ccim, G)</p>
<p>&ndash;</p>
<p>可以看到，网络整体的架构还是属于encoder-decoder的建构的，不同在于，结尾输出的loss有两个。而这两个loss也将整个网络划分成了两个功能块——Search Module (SM)和 Identification Module (IM)，而两个loss的计算逻辑都是将两个模块解码器最终的特征图上采样，再与原图伪装物体的显著图做交叉熵得到的。</p>
<p>第一个loss是用来衡量原图中有没有伪装物的，第二个loss是用来衡量模型预测的伪装物的位置准不准的。</p>
<p>在SM模块中，在5层卷积的基础上，将[X0,X1]，[X2,X3,X4]，[X3,X4]以及[X4]送入四个RF模块，最后做一个PDC，也就是一个解码器。</p>
<p>此处所谓的RF(reception field)和Google的Inception v3系列网络很像，都是通过1x1卷积与双串联式的架构来减少网络参数，从而达到瓶颈训练的效果，同时也是<code>增大感受野</code>的一种方式，而在COD或者其他的一些显著物检测上，增大感受野是提高预测精度的一种常用方式。</p>
<p>做完四个RF，如何将四个RF得到的<code>特征图融合</code>就是decoder干的事情了，此处的decoder，也就是<code>PDC</code>，大致逻辑也很简单，就是先将后面三个RF得到的特征图上采样到和第一个RF得到的特征图一样的尺寸，然后根据论文中一个elementwise的乘法，将最终decoder得到的四个特征图做拼接，就可以得到PDC的输出了,而第一个PDC的输出也就是第一个模块——SM模块的输出内容了。</p>
<p>关于第二个模块IM，根据文章之前的说法，猎人在得知有猎物存在后，需要知道猎物的大致位置，因此，与SM模块相比，IM模块更加需要关于伪装物轮廓<code>边缘信息</code>。</p>
<p>DCNN的<code>底层输出的特征图多是关于物体边缘轮廓信息</code>的，中层是关于空间位置信息的，而高层多是关于语义信息的。</p>
<p>所以IM在SM原本CNN encoder的基础上，取第三层卷积输出的特征图X2，因为底层能够保留更多的轮廓信息，并将X2与SM的输出结果来做一个简单的fusion，不过原文中是将这个fusion称为一种attention机制。个人认为这么做的目的就是在确保SM模块的输入有较多的边缘轮廓信息的前提下利用全局信息消除无关特征</p>
<p>SA :Ch=  fmax(g(x2,σ,λ),Cs)，目的是为了<code>强调原本的伪装物区域</code>。Cs是SM模块的输出结果，g(.)则是一个简单的高斯滤波器</p>
<p>之后的IM主体就是一个简单的encoder-decoder架构了，decoder采用的PDC和之前一样，输出的结果便是IM的输出了。</p>
<p>最终将IM和SM的输出结果分别上采样到和原图的GT一样大，分别做交叉熵得到 ls 和 ld ，加起来就是最终的loss了。</p>
<h2 id="代码">代码</h2>
<p>这段代码实现了一个名为 <code>SA</code> 的自定义模块，用于执行全局注意力机制。 首先，代码中定义了一个 <code>_get_kernel</code> 函数，用于生成一个二维高斯核。该函数接受两个参数：<code>kernlen</code>（核的长度，默认为 16）和 <code>nsig</code>（高斯标准差，默认为 3）。它通过计算标准正态分布在给定范围内的概率密度函数，生成一个二维的高斯核。这个高斯核用于后续的卷积操作。 接下来，代码定义了一个 <code>min_max_norm</code> 函数，用于执行归一化操作。该函数接受一个输入张量 <code>in_</code>，并执行以下步骤： - 计算输入张量在第 3 和第 2 维度上的最大值和最小值，并扩展为与输入张量相同的形状。 - 将输入张量减去最小值。 - 将结果除以最大值与最小值之差，加上一个很小的常数（1e-8）以避免除以零。 接下来，定义了一个名为 <code>SA</code> 的自定义模块（<code>nn.Module</code> 的子类），用于执行全局注意力机制。 在 <code>__init__</code> 函数中，定义了一个 <code>gaussian_kernel</code> 参数，它是通过调用 <code>_get_kernel</code> 函数生成的高斯核，并将其转换为 <code>torch.Tensor</code> 类型的参数。 在前向传播函数 <code>forward</code> 中，输入参数 <code>attention</code> 和 <code>x</code> 分别表示注意力图和特征图。代码使用 <code>F.conv2d</code> 函数对注意力图进行卷积操作，使用之前定义的高斯核进行卷积，并进行边缘填充（padding）操作。然后，通过调用 <code>min_max_norm</code> 函数对卷积结果进行归一化操作。最后，将特征图 <code>x</code> 与归一化后的注意力图相乘，得到最终的输出。 这个 <code>SA</code> 模块可以用于在神经网络中引入全局注意力机制，以增强对特定区域的关注和重要性。</p>
<p>&ndash;</p>
<p>通过在 <strong><code>__init__</code></strong> 函数中进行初始化操作，可以在创建 <strong><code>SINet</code></strong> 类的实例时，为实例的属性赋予初始值。这样，在实例被创建后，就可以直接使用这些属性，并在其他方法中进行操作。</p>
<p>总体而言，该 <strong><code>forward</code></strong> 方法实现了一个残差块的前向传播过程，通过将输入特征与中间特征相加，以及进行卷积和批归一化操作，生成最终的输出特征。</p>
<p><code>resnet</code></p>
<p>该网络是一个基于 ResNet50 的修改版，包含了两个分支。下面是各个层的功能：</p>
<ul>
<li><strong><code>conv1</code></strong>：一个 7x7 的卷积层，输入通道数为 3，输出通道数为 64。</li>
<li><strong><code>bn1</code></strong>：一个批归一化层，对 <strong><code>conv1</code></strong> 的输出进行归一化。</li>
<li><strong><code>relu</code></strong>：一个 ReLU 激活函数，对 <strong><code>bn1</code></strong> 的输出进行非线性激活。</li>
<li><strong><code>maxpool</code></strong>：一个最大池化层，对特征图进行下采样。</li>
<li><strong><code>layer1</code></strong>：第一个残差层，包含 3 个 <strong><code>Bottleneck</code></strong> 残差块。</li>
<li><strong><code>layer2</code></strong>：第二个残差层，包含 4 个 <strong><code>Bottleneck</code></strong> 残差块。</li>
<li><strong><code>layer3_1</code></strong>：第三个残差层的第一个分支，包含 6 个 <strong><code>Bottleneck</code></strong> 残差块。</li>
<li><strong><code>layer4_1</code></strong>：第四个残差层的第一个分支，包含 3 个 <strong><code>Bottleneck</code></strong> 残差块。</li>
<li><strong><code>layer3_2</code></strong>：第三个残差层的第二个分支，包含 6 个 <strong><code>Bottleneck</code></strong> 残差块。</li>
<li><strong><code>layer4_2</code></strong>：第四个残差层的第二个分支，包含 3 个 <strong><code>Bottleneck</code></strong> 残差块。</li>
<li><strong><code>output</code></strong>：网络的输出，包括两个分支的输出。</li>
</ul>
<p>常规resnet网络由以下几个主要组件组成：</p>
<ul>
<li><strong><code>conv1</code></strong>：一个 7x7 的卷积层，输入通道数为 3，输出通道数为 64。</li>
<li><strong><code>bn1</code></strong>：一个批归一化层，对 <strong><code>conv1</code></strong> 的输出进行归一化。</li>
<li><strong><code>relu</code></strong>：一个 ReLU 激活函数，对 <strong><code>bn1</code></strong> 的输出进行非线性激活。</li>
<li><strong><code>maxpool</code></strong>：一个最大池化层，对特征图进行下采样。</li>
<li><strong><code>layer1</code></strong>：第一个残差层，包含 3 个 <strong><code>Bottleneck</code></strong> 残差块。</li>
<li><strong><code>layer2</code></strong>：第二个残差层，包含 4 个 <strong><code>Bottleneck</code></strong> 残差块。</li>
<li><strong><code>layer3</code></strong>：第三个残差层，包含 6 个 <strong><code>Bottleneck</code></strong> 残差块。</li>
<li><strong><code>layer4</code></strong>：第四个残差层，包含 3 个 <strong><code>Bottleneck</code></strong> 残差块。</li>
<li><strong><code>avgpool</code></strong>：一个平均池化层，对特征图进行全局平均池化。</li>
<li><strong><code>fc</code></strong>：一个全连接层，将特征图映射到输出类别的维度。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">torch</span>  
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>  
  
<span class="c1"># 定义 Bottleneck 残差块  </span>
<span class="k">class</span> <span class="nc">Bottleneck</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>  
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">downsample</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  
        <span class="nb">super</span><span class="p">(</span><span class="n">Bottleneck</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">in_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">bn1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">out_channels</span><span class="p">)</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">conv2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">out_channels</span><span class="p">,</span> <span class="n">out_channels</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">bn2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">out_channels</span><span class="p">)</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">conv3</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">out_channels</span><span class="p">,</span> <span class="n">out_channels</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">bn3</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">out_channels</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">relu</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">downsample</span> <span class="o">=</span> <span class="n">downsample</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">stride</span> <span class="o">=</span> <span class="n">stride</span>  
  
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>  
        <span class="n">identity</span> <span class="o">=</span> <span class="n">x</span>  
  
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn1</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>  
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>  
  
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv2</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>  
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn2</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>  
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>  
  
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv3</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>  
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn3</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>  
  
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  
            <span class="n">identity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
  
        <span class="n">out</span> <span class="o">+=</span> <span class="n">identity</span>  
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>  
  
        <span class="k">return</span> <span class="n">out</span>  
  
<span class="c1"># 定义 ResNet50 网络  </span>
<span class="k">class</span> <span class="nc">ResNet50</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>  
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_classes</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>  
        <span class="nb">super</span><span class="p">(</span><span class="n">ResNet50</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">bn1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">relu</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">maxpool</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">MaxPool2d</span><span class="p">(</span><span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">layer1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_layer</span><span class="p">(</span><span class="n">Bottleneck</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">layer2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_layer</span><span class="p">(</span><span class="n">Bottleneck</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">layer3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_layer</span><span class="p">(</span><span class="n">Bottleneck</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">layer4</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_layer</span><span class="p">(</span><span class="n">Bottleneck</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">avgpool</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">AdaptiveAvgPool2d</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">fc</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">512</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">)</span>  
  
    <span class="k">def</span> <span class="nf">_make_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">blocks</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>  
        <span class="n">downsample</span> <span class="o">=</span> <span class="kc">None</span>  
        <span class="k">if</span> <span class="n">stride</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">channels</span> <span class="o">!=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">4</span><span class="p">:</span>  
            <span class="n">downsample</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>  
                <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">channels</span><span class="p">,</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>  
                <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">64</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span>  
            <span class="p">)</span>  
  
        <span class="n">layers</span> <span class="o">=</span> <span class="p">[]</span>  
        <span class="n">layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block</span><span class="p">(</span><span class="n">channels</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">downsample</span><span class="p">))</span>  
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">blocks</span><span class="p">):</span>  
            <span class="n">layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block</span><span class="p">(</span><span class="mi">64</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">64</span><span class="p">))</span>  
  
        <span class="k">return</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="n">layers</span><span class="p">)</span>  
  
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>  
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxpool</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
  
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer3</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer4</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
  
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">avgpool</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  
  
        <span class="k">return</span> <span class="n">x</span>  
  
<span class="c1"># 创建 ResNet50 模型实例  </span>
<span class="n">model</span> <span class="o">=</span> <span class="n">ResNet50</span><span class="p">()</span>  
  
<span class="c1"># 打印模型结构  </span>
<span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>  
</code></pre></td></tr></table>
</div>
</div><p>修改输出类别</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python">	<span class="n">model</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">resnet50</span><span class="p">(</span><span class="n">pretrained</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
    <span class="c1"># (avgpool): AdaptiveAvgPool2d(output_size=(1, 1))</span>
    <span class="c1">#   (fc): Linear(in_features=2048, out_features=1000, bias=True)</span>
    <span class="n">fc_inputs</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">fc</span><span class="o">.</span><span class="n">in_features</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">fc_inputs</span><span class="p">)</span>
    <span class="n">model</span><span class="o">.</span><span class="n">fc</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">fc_inputs</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">fc</span><span class="p">)</span>
    <span class="c1"># 2048</span>
    <span class="c1"># Linear(in_features=2048, out_features=214, bias=True)</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>forward方法实现了网络的前向传播过程。输入 <strong><code>x</code></strong> 经过一系列的卷积、批归一化、激活函数和池化层后，分别经过 <strong><code>layer1</code></strong>、<strong><code>layer2</code></strong>、<strong><code>layer3_1</code></strong> 和 <strong><code>layer4_1</code></strong>，得到输出特征 <strong><code>x1</code></strong>。同时，输入 <strong><code>x</code></strong> 经过 <strong><code>layer3_2</code></strong> 和 <strong><code>layer4_2</code></strong>，得到输出特征 <strong><code>x2</code></strong>。</p>
<p>因此，<strong><code>x1</code></strong> 和 <strong><code>x2</code></strong> 是两个不同分支的输出特征。它们在网络结构中具有不同的路径，经过不同的残差块和卷积操作。这种设计可以用于多任务学习、特征融合或其他需要多个分支的场景。具体应用中，可以根据需要使用 <strong><code>x1</code></strong> 和 <strong><code>x2</code></strong> 进行后续处理、特征融合或用于不同的任务。</p>
<p>SA</p>
<p>这段代码定义了一个名为SA的PyTorch模型类。它实现了一个holistic attention机制。 在<code>__init__</code>方法中，代码通过<code>_get_kernel</code>函数生成了一个大小为31x31的高斯卷积核，并将其转换为PyTorch的<code>Parameter</code>类型。这个高斯卷积核将用于后续的卷积操作。 在<code>forward</code>方法中，代码接收两个输入参数：attention和x。其中，attention表示注意力图，x表示输入的特征图。代码首先将attention图与高斯卷积核进行卷积操作，并进行填充(padding)以保持输入输出的尺寸一致。然后，通过min-max归一化函数进行归一化处理。接下来，将x与attention图的最大值相乘，实现了特征图x的加权操作。最后，返回加权后的特征图x。 这段代码的作用是对输入的特征图x进行holistic attention操作，根据注意力图attention对特征图进行加权，以增强重要的特征。</p>
<p>&ndash;</p>
<p>这段代码对应的是一个名为SINet_ResNet50的网络模型，它基于ResNet50的编码器-解码器结构。</p>
<p>网络结构如下：</p>
<ul>
<li>特征抽象部分：
<ul>
<li>头部（head）：通过卷积、批归一化和ReLU激活函数进行特征提取。</li>
<li>低级特征（low-level features）：通过最大池化层和ResNet的第一个layer进行特征提取。</li>
<li>第二层（layer2）：通过ResNet的第二个layer进行特征提取。<br>
-Stage-1: Search Module (SM)：</li>
<li>将低级特征和第一层特征进行拼接，然后经过下采样和RF模块进行特征提取。</li>
<li>第二层特征经过RF模块进行特征提取。</li>
<li>第三层特征经过RF模块进行特征提取。</li>
<li>第四层特征经过RF模块进行特征提取。</li>
<li>使用PDC_SM模块将提取的特征进行处理得到camouflage_map_sm。</li>
</ul>
</li>
<li>Switcher: Search Attention (SA)：
<ul>
<li>使用SA模块对camouflage_map_sm和第二层特征进行处理得到x2_sa。</li>
</ul>
</li>
<li>Stage-2: Identification Module (IM)：
<ul>
<li>第三层特征经过第二个layer进行特征提取。</li>
<li>第四层特征经过第二个layer进行特征提取。</li>
<li>第二层特征经过RF模块进行特征提取。</li>
<li>第三层特征经过RF模块进行特征提取。</li>
<li>第四层特征经过RF模块进行特征提取。</li>
<li>使用PDC_IM模块将提取的特征进行处理得到camouflage_map_im。</li>
</ul>
</li>
<li>输出：
<ul>
<li>返回经过上采样的camouflage_map_sm和camouflage_map_im。 这个网络模型主要用于图像隐写分析任务。</li>
</ul>
</li>
</ul>
<p>&ndash;</p>
<p>scipy1.2.2  <a href="https://blog.csdn.net/huang1024rui/article/details/119668502">imsave</a> <a href="https://blog.csdn.net/weixin_44042453/article/details/127473478">2</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"> <span class="n">pip3</span> <span class="n">install</span> <span class="o">--</span><span class="n">upgrade</span> <span class="n">pip</span>
<span class="c1"># https://www.cnblogs.com/peixu/p/14614013.html#:~:text=1%E3%80%81git%20clone%20git%40github.com%3ANVIDIA%2Fapex.git,2%E3%80%81%E5%BC%80cmd%E5%91%BD%E4%BB%A4%E7%AA%97%E5%8F%A3%EF%BC%8C%E5%88%87%E6%8D%A2%E5%88%B0apex%E6%89%80%E5%9C%A8%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%203%E3%80%81python%20setup.py%20install</span>
<span class="n">python</span> <span class="n">setup</span><span class="o">.</span><span class="n">py</span> <span class="n">install</span>
<span class="n">conda</span> <span class="n">install</span> <span class="o">-</span><span class="n">c</span> <span class="n">conda</span><span class="o">-</span><span class="n">forge</span> <span class="n">nvidia</span><span class="o">-</span><span class="n">apex</span>


</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="c1"># paper</span>
<span class="p">{</span><span class="s1">&#39;Smeasure&#39;</span><span class="p">:</span> <span class="mf">0.7762281331568003</span><span class="p">,</span> <span class="s1">&#39;wFmeasure&#39;</span><span class="p">:</span> <span class="mf">0.6310046513108765</span><span class="p">,</span> <span class="s1">&#39;MAE&#39;</span><span class="p">:</span> <span class="mf">0.042614733798974784</span><span class="p">,</span> <span class="s1">&#39;adpEm&#39;</span><span class="p">:</span> <span class="mf">0.86695971862112</span><span class="p">,</span> <span class="s1">&#39;meanEm&#39;</span><span class="p">:</span> <span class="mf">0.8635102776241943</span><span class="p">,</span> <span class="s1">&#39;maxEm&#39;</span><span class="p">:</span> <span class="mf">0.8746242151987729</span><span class="p">,</span> <span class="s1">&#39;adpFm&#39;</span><span class="p">:</span> <span class="mf">0.6670583855153248</span><span class="p">,</span> <span class="s1">&#39;meanFm&#39;</span><span class="p">:</span> <span class="mf">0.6791200438546587</span><span class="p">,</span> <span class="s1">&#39;maxFm&#39;</span><span class="p">:</span> <span class="mf">0.6908318653815608</span><span class="p">}</span>
<span class="c1"># test</span>
<span class="p">{</span><span class="s1">&#39;Smeasure&#39;</span><span class="p">:</span> <span class="mf">0.757855827894297</span><span class="p">,</span> <span class="s1">&#39;wFmeasure&#39;</span><span class="p">:</span> <span class="mf">0.5506477369940896</span><span class="p">,</span> <span class="s1">&#39;MAE&#39;</span><span class="p">:</span> <span class="mf">0.05048519826051167</span><span class="p">,</span> <span class="s1">&#39;adpEm&#39;</span><span class="p">:</span> <span class="mf">0.798543892694507</span><span class="p">,</span> <span class="s1">&#39;meanEm&#39;</span><span class="p">:</span> <span class="mf">0.7831408148773497</span><span class="p">,</span> <span class="s1">&#39;maxEm&#39;</span><span class="p">:</span> <span class="mf">0.854691225152544</span><span class="p">,</span> <span class="s1">&#39;adpFm&#39;</span><span class="p">:</span> <span class="mf">0.5912450146637638</span><span class="p">,</span> <span class="s1">&#39;meanFm&#39;</span><span class="p">:</span> <span class="mf">0.6132905844614</span><span class="p">,</span> <span class="s1">&#39;maxFm&#39;</span><span class="p">:</span> <span class="mf">0.6561096578776877</span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="基于像素与层级双对比的语义分割">基于像素与层级双对比的语义分割</h2>
<p>语义分割实现了图像像素级的分类。它能够将一张图片或者视频，按照类别的异同，将图像分为多个块。</p>
<p>语义分割数据集的图像中往往含有多个目标对象，且它们之间存在相互作用的关系[9]。所以如何有效地获取图像内的上下文信息成为提升语义分割性能的关键。</p>
<p>经过对比学习训练的网络在部分下游任务中甚至强过传统的神经网络[14–16]。传统的对比学习在执行下游语义分割任务往往分两步：首先，训练一个基于对比学习的主干网络；然后，针对语义分割任务对训练好的主干网络进行微调得到一个语义分割网络。但是，由于这两阶段相互独立，且现有的主干网络在对比学习过程中并没有很好的建模语义信息，导致模型在训练时产生割裂，使得通过对比学习学到的良好特征不能有效融入到语义分割网络。</p>
<p>现有方法一般将对比学习作用于主干网络之后分割头之前（Before）的特征[17]，或者将对比学习作用于分类头之前分割头之后（After）的特征[18]。另外，语义分割网络的主干网络与分割头之间一般通过降维（卷积）操作，得到适合分割的分割特征（Intra）。因此，为充分利用对比学习提升语义分割性能，本文对对比学习位置进行了深入分析与实验验证，重点分析了在Intra处引入对比学习的端到端的语义分割网络。</p>
<p>不同大小和形状的符号分别表示不同尺寸和类别的特征，左侧为原特征空间，右侧为经过对比学习训练得到的嵌入式特征空间。可以发现在嵌入式特征空间中不同类别的特征被更好的区分。但是，由于没有考虑到语义分割模型对多尺度目标的检测需求，一些不同尺度的物体仍然没有得到有效区分，从而造成不同类别间的边界模糊。</p>
<p>为解决这个问题，本文设计了<code>多尺度嵌入式映射模块</code>(Multi-scale Embedded Projector, MEP)，采用空洞卷积生成三个不同尺度的嵌入式特征空间，针对不同尺度的特征进行对比学习，获得多尺度特征信息</p>
<p>另外，为了更好的利用获取的多尺度特征信息，不仅不同层级特征内部进行像素级对比学习，不同层级之间也进行了层级对比学习。最后，在像素与层级双对比（Double Contrast, DC）的作用下，不同特征在嵌入式特征空间中得到的了更好的划分。</p>
<p>在对比学习中，与正样本高度相似的负样本和与正样本高度区分的正样本统称为难样本。尽管难样本会诱导分类错误，损害分割精度，但是Kalantidis等人[19]发现难样本会带来更大的梯度贡献，在训练后期为模型提供更大的帮助。基于此，本文提出了激励式样本采样策略(Excitation Sampling，ES），把一幅图片中的同一类别的难样本和简单样本通过一定的采集策略组织成一个样本，并通过动态调整样本中的难样本和简单样本的权重为模型提供优质样本。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">kong</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2023-07-26
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/object-detection/">Object Detection</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/latex/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Latex</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/fl_pfl/">
            <span class="next-text nav-default">个性化联邦学习</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=_JOXlp_emZaBjZ3IwcrMuImJ1puXlQ" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/kongfany" class="iconfont icon-github" title="github"></a>
      <a href="https://weibo.com/u/5947688533?is_all=1" class="iconfont icon-weibo" title="weibo"></a>
      <a href="https://www.zhihu.com/people/yu-ni-zhong-nian-bu-yu" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="https://space.bilibili.com/232669848" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="https://kongfany.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2023<span class="heart"><i class="iconfont icon-heart"></i></span><span>kong</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script type="text/javascript" async src="/lib/mathjax/es5/tex-mml-chtml.js"></script>








</body>
</html>
